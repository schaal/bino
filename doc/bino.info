This is bino.info, produced by makeinfo version 6.8 from bino.texi.

This manual was last updated 4 November 2021 for version 1.6.8 of Bino.

   Copyright © 2011, 2012, 2013, 2014, 2018, 2019, 2020, 2021 Martin
Lambers (<marlam@marlam.de>), Stefan Eilemann (<eile@eyescale.ch>),
Frédéric Devernay (<Frederic.Devernay@inrialpes.fr>)

     Copying and distribution of this file and the accompanying media
     files, with or without modification, are permitted in any medium
     without royalty provided the copyright notice and this notice are
     preserved.  These files are offered as-is, without any warranty.
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* bino: (bino).         A 3D video player with multi-display support.
END-INFO-DIR-ENTRY


File: bino.info,  Node: Top,  Next: Introduction,  Up: (dir)

Bino
****

This manual was last updated 4 November 2021 for version 1.6.8 of Bino.

   Copyright © 2011, 2012, 2013, 2014, 2018, 2019, 2020, 2021 Martin
Lambers (<marlam@marlam.de>), Stefan Eilemann (<eile@eyescale.ch>),
Frédéric Devernay (<Frederic.Devernay@inrialpes.fr>)

     Copying and distribution of this file and the accompanying media
     files, with or without modification, are permitted in any medium
     without royalty provided the copyright notice and this notice are
     preserved.  These files are offered as-is, without any warranty.

* Menu:

* Introduction::
* Invocation::
* Input Layouts::
* Output Techniques::
* Interactive Control::
* Scripting::
* Camera Devices::
* Audio/Video Synchronization::
* Performance Tweaking::


File: bino.info,  Node: Introduction,  Next: Invocation,  Prev: Top,  Up: Top

1 Introduction
**************

Bino is a 3D video player with multi-display support.

   3D videos are more accurately called stereoscopic videos.  Such
videos have separate views for the left and right eye and thus allow
depth perception through stereopsis.

   The left and right view of a stereoscopic video can be stored using
different layouts.  Sometimes the two views are stored as two separate
video streams, but most often both views are packed into a single video
stream and need to be unpacked by the video player.  Bino supports all
commonly used layouts.  *Note Input Layouts::.

   To display a stereoscopic video, the left and right view have to be
prepared in a special way so that the left eye sees the left view and
the right eye sees the right view.  Different display techniques use
different approaches to achieve this separation of the two views.  Bino
supports a wide variety of such techniques.  *Note Output Techniques::.


File: bino.info,  Node: Invocation,  Next: Input Layouts,  Prev: Introduction,  Up: Top

2 Invocation
************

This section describes the command line interface of Bino.

   Synopsis: ‘bino [OPTION...] [FILE...]’

   Bino combines all input files into one media source which is then
played.  This means you can have video, audio, and subtitle streams in
separate files.  The files are decoded with the FFmpeg
(http://ffmpeg.org/) libraries, so URLs and other special constructs are
supported.

‘--help’
     Print help.
‘--version’
     Print version.
‘-n’
‘--no-gui’
     Do not use the GUI, just play the given input in a plain window
     using the parameters given on the command line.
‘--log-file=FILE’
     Append all log messages to the given file.
‘-L’
‘--log-level=LEVEL’
     Select log level: DEBUG, INFO, WARNING, ERROR, or QUIET.
‘--list-audio-devices’
     Print a list of known audio devices and exit.
‘-A’
‘--audio-device=N’
     Use audio device number N.  N=0 is the default device.
‘D’
‘--audio-delay=D’
     Delay audio by D milliseconds.  Default is 0.
‘-V’
‘--audio-volume=V’
     Set audio volume (0 to 1).  Default is 1.
‘-m’
‘--audio-mute’
     Mute audio.
‘--device-type=TYPE’
     Type of input device: DEFAULT, FIREWIRE, or X11.
‘--device-frame-size=WxH’
     If the input is a device, request the given frame size, e.g.
     640x480.
‘--device-frame-rate=N/D’
     If the input is a device, request the given frame rate, e.g.  25/1.
‘--device-format=FORMAT’
     Request format DEFAULT or MJPEG from device.
‘--read-commands=FILE’
     Read commands from file.  *Note Scripting::.
‘--lirc-config=FILE’
     Use the given LIRC configuration file.  This option can be used
     more than once.
‘--quality=Q"’
     Set rendering quality, from 0 (fastest) to 4 (best, default).
‘-v’
‘--video=STREAM’
     Select video stream (1-n, depending on the input).
‘-a’
‘--audio=STREAM’
     Select audio stream (1-n, depending on the input).
‘-s’
‘--subtitle=STREAM’
     Select subtitle stream (1-n, depending on the input).
‘-i’
‘--input=TYPE’
     Select input layout.  *Note Input Layouts::.
‘-o’
‘--output=TYPE’
     Select output technique.  *Note Output Techniques::.
‘-S’
‘--swap-eyes’
     Swap left/right view.
‘-f’
‘--fullscreen’
     Fullscreen.
‘--fullscreen-screens=[S0[,S1[,...]]]’
     Use the listed screens S0, ..., SN in fullscreen mode.  Screen
     numbers start with 1.  If the list is empty, the primary screen
     will be used (this is the default).
‘--fullscreen-flip-left’
     Flip left view vertically when in fullscreen mode.
‘--fullscreen-flop-left’
     Flop left view horizontally when in fullscreen mode.
‘--fullscreen-flip-right’
     Flip right view vertically when in fullscreen mode.
‘--fullscreen-flop-right’
     Flop right view horizontally when in fullscreen mode.
‘--fullscreen-3dr-sync’
     Use DLP® 3-D Ready Sync when in fullscreen mode.
‘-z’
‘--zoom=Z’
     Set zoom for videos that are wider than the screen, from 0 (off;
     show full video width) to 1 (full; use full screen height).  The
     default is 0.
‘-C’
‘--crop=W:H’
     Crop the video to the given aspect ratio, to remove borders.  0:0
     disables cropping.
‘-c’
‘--center’
     Center window on screen.
‘--subtitle-encoding=ENC’
     Set subtitle encoding.
‘--subtitle-font=FONT’
     Set subtitle font name.
‘--subtitle-size=N’
     Set subtitle font size.
‘--subtitle-scale=S’
     Set subtitle scale factor.
‘--subtitle-color=COLOR’
     Set subtitle color, in [AA]RRGGBB format.
‘--subtitle-shadow=-1|0|1’
     Set subtitle shadow, -1=default, 0=off, 1=on.
‘--subtitle-parallax=VAL’
     Subtitle parallax adjustment (-1 to +1).
‘-P’
‘--parallax=VAL’
     Parallax adjustment (-1 to +1).
‘--crosstalk=VAL’
     Crosstalk leak level (0 to 1).  Comma-separated values for the
     R,G,B channels.
‘--ghostbust=VAL’
     Amount of crosstalk ghostbusting to apply (0 to 1).
‘-b’
‘--benchmark’
     Benchmark mode: no audio, no time synchronization, output of
     frames-per-second measurements.
‘--swap-interval=D’
     Frame rate divisor relative to display refresh rate.  The default
     is 0 for benchmark mode and 1 otherwise.
‘-l’
‘--loop’
     Loop the input media.
‘--set-vertical-pixel-shift-left=L’
     Set left vertical shift in input pixels.
‘--set-vertical-pixel-shift-right=R’
     Set right vertical shift in input pixels.


File: bino.info,  Node: Input Layouts,  Next: Output Techniques,  Prev: Invocation,  Up: Top

3 Input Layouts
***************

3.1 Overview
============

The left and right view of a stereoscopic video can be stored using
different layouts.  Sometimes they are stored in separate files,
sometimes in separate streams inside the same file, and often they are
packed into a single video on top of each other or next to each other,
with or without a reduction of resolution.

   By default, Bino autodetects the input layout from meta data stored
in the file (for example, the Matroska and WebM formats have a
‘StereoMode’ field for that purpose).  If no meta data is available,
Bino tries to autodetect the input layout based on the file name.  *Note
File Name Conventions::.  If that fails, too, Bino guesses based on the
resolution of the input.

3.2 Supported Input Layouts
===========================

MONO
     Single view (2D conventional video).
      [image src="input-layout-mono.png" ]
SEPARATE-LEFT-RIGHT
     Separate streams: left view first, right view second.
      [image src="input-layout-separate-left-right.png" ]
SEPARATE-RIGHT-LEFT
     Separate streams: right view first, left view second.
      [image src="input-layout-separate-right-left.png" ]
ALTERNATING-LEFT-RIGHT
     Alternating frames: left view first, right view second.
      [image src="input-layout-alternating-left-right.png" ]
ALTERNATING-RIGHT-LEFT
     Alternating frames: right view first, left view second.
      [image src="input-layout-alternating-right-left.png" ]
TOP-BOTTOM
     Single stream: left view top, right view bottom.
      [image src="input-layout-top-bottom.png" ]
TOP-BOTTOM-HALF
     Single stream: left view top, right view bottom, both with half
     height.
      [image src="input-layout-top-bottom-half.png" ]
BOTTOM-TOP
     Single stream: right view top, left view bottom.
      [image src="input-layout-bottom-top.png" ]
BOTTOM-TOP-HALF
     Single stream: right view top, left view bottom, both with half
     height.
      [image src="input-layout-bottom-top-half.png" ]
LEFT-RIGHT
     Single stream: left view left, right view right.
      [image src="input-layout-left-right.png" ]
LEFT-RIGHT-HALF
     Single stream: left view left, right view right, both with half
     width.
      [image src="input-layout-left-right-half.png" ]
RIGHT-LEFT
     Single stream: right view left, left view right.
      [image src="input-layout-right-left.png" ]
RIGHT-LEFT-HALF
     Single stream: right view left, left view right, both with half
     width.
      [image src="input-layout-right-left-half.png" ]
EVEN-ODD-ROWS
     Single stream: left view in even rows, right view in odd rows.
      [image src="input-layout-even-odd-rows.png" ]
ODD-EVEN-ROWS
     Single stream: right view in even rows, left view in odd rows.
      [image src="input-layout-odd-even-rows.png" ]

3.3 File Name Conventions
=========================

If the meta data stored in a file does not indicate the input layout,
Bino tries to guess it by looking at the last part of the file name
before the file name extension (‘.ext’).

   The following file name forms are recognized:
‘*-lr.ext’
     Input layout LEFT-RIGHT.
‘*-lrh.ext’
‘*-lrq.ext’
     Input layout LEFT-RIGHT-HALF.
‘*-rl.ext’
     Input layout RIGHT-LEFT.
‘*-rlh.ext’
‘*-rlq.ext’
     Input layout RIGHT-LEFT-HALF.
‘*-tb.ext’
‘*-ab.ext’
     Input layout TOP-BOTTOM.
‘*-tbh.ext’
‘*-abq.ext’
     Input layout TOP-BOTTOM-HALF.
‘*-bt.ext’
‘*-ba.ext’
     Input layout BOTTOM-TOP.
‘*-bth.ext’
‘*-baq.ext’
     Input layout BOTTOM-TOP-HALF.
‘*-eo.ext’
‘*-eoq.ext’
‘*-3dir.ext’
     Input layout EVEN-ODD-ROWS.
‘*-oe.ext’
‘*-oeq.ext’
‘*-3di.ext’
     Input layout ODD-EVEN-ROWS.
‘*-2d.ext’
     Input layout MONO.


File: bino.info,  Node: Output Techniques,  Next: Interactive Control,  Prev: Input Layouts,  Up: Top

4 Output Techniques
*******************

4.1 Overview
============

The left and right view of a stereoscopic video need to be displayed in
a way that ensures that the left view is only seen by the left eye of
the user and the right view is only seen by the right eye.  There are
many different techniques to achieve this separation of left and right
view, and Bino supports most of them.

   With some display techniques, some part of the right view may also
seen by the left eye and vice versa.  This is called crosstalk and leads
to ghosting artefacts that reduce image quality.  For some display
types, Bino can reduce such artefacts.  *Note Crosstalk Ghostbusting::.

   One of the simplest output techniques is anaglyph glasses.  Such
glasses use color filters to separate the left and right view.  Anaglyph
glasses are cheap and work with every display, but the view separation
and color reproduction are of relatively low quality.  Still, depending
on the video material, Bino can achieve high quality results using the
Dubois method (http://www.site.uottawa.ca/~edubois/anaglyph/) to produce
video output for anaglyph glasses.

   With OpenGL, the default method to display stereoscopic 3D content is
OpenGL quad buffered stereo, often used with active shutter glasses.
However, graphics card manufacturers tend to enable this output
technique only on expensive high end hardware.

   Many 3D computer displays use polarized glasses to separate left and
right view, and some autostereoscopic displays do not require any
glasses at all.  Most of these 3D computer displays expect left and
right view packed in a single video frame, e.g.  on top of each other or
next to each other or partitioned into even and odd pixel lines or
columns.  Bino supports all variants of such modes; refer to the manual
of your display to find out which mode is required.

   Another common way to display 3D stereoscopic content is to use two
conventional 2D displays or projectors for the left and right view and
combine both views either using a half-transparent mirror, or a single
screen with polarized glasses.  This is supported in Bino using
multiscreen output.  *Note Basic Multi Display Support::.

   For more complex setups, such as powerwalls or virtual reality
installations driven by render clusters, Bino supports distributed video
rendering via Equalizer.  *Note Advanced Multi Display Support::.

   The default output technique for stereoscopic 3D input is OpenGL quad
buffered stereo if the graphics card supports it, otherwise red/cyan
anaglyph glasses.

4.2 Supported Output Techniques
===============================

STEREO
     OpenGL quad-buffer stereo.
      [image src="output-type-stereo.png" ]
ALTERNATING
     Left and right view alternating.  This can be used for shutter
     glasses on systems that do not support OpenGL quad-buffer stereo,
     but note that this mode may be unreliable and may swap left/right
     eyes occasionally, depending on your system.  In case of problems,
     disabling the fullscreen mode screensaver inhibition may help.
      [image src="output-type-alternating.png" ]
MONO-LEFT
     Left view only.
      [image src="output-type-mono-left.png" ]
MONO-RIGHT
     Right view only.
      [image src="output-type-mono-right.png" ]
TOP-BOTTOM
     Left view top, right view bottom.
      [image src="output-type-top-bottom.png" ]
TOP-BOTTOM-HALF
     Left view top, right view bottom, both with half height.
      [image src="output-type-top-bottom-half.png" ]
LEFT-RIGHT
     Left view left, right view right.
      [image src="output-type-left-right.png" ]
LEFT-RIGHT-HALF
     Left view left, right view right, both with half width.
      [image src="output-type-left-right-half.png" ]
EVEN-ODD-ROWS
     Left view in even rows, right view in odd rows.
      [image src="output-type-even-odd-rows.png" ]
EVEN-ODD-COLUMNS
     Left view in even columns, right view in odd columns.
      [image src="output-type-even-odd-columns.png" ]
CHECKERBOARD
     Left and right view in a checkerboard pattern.
      [image src="output-type-checkerboard.png" ]
HDMI-FRAME-PACK
     HDMI frame packing mode (left top, right bottom, plus extra blank
     lines separating the two views).  This mode is only necessary if
     you are forcing your display into the corresponding HDMI 3D mode.
     A description how to do this on GNU/Linux can be found in this post
     to the Bino mailing list
     (http://lists.nongnu.org/archive/html/bino-list/2011-03/msg00033.html).
      [image src="output-type-hdmi-frame-pack.png" ]
RED-CYAN-MONOCHROME
     Red/cyan anaglyph glasses, monochrome method.
      [image src="output-type-red-cyan.png" ]
RED-CYAN-HALF-COLOR
     Red/cyan anaglyph glasses, half color method.
      [image src="output-type-red-cyan.png" ]
RED-CYAN-FULL-COLOR
     Red/cyan anaglyph glasses, full color method.
      [image src="output-type-red-cyan.png" ]
RED-CYAN-DUBOIS
     Red/cyan anaglyph glasses, high-quality Dubois method.
      [image src="output-type-red-cyan.png" ]
GREEN-MAGENTA-MONOCHROME
     Green/magenta anaglyph glasses, monochrome method.
      [image src="output-type-green-magenta.png" ]
GREEN-MAGENTA-HALF-COLOR
     Green/magenta anaglyph glasses, half color method.
      [image src="output-type-green-magenta.png" ]
GREEN-MAGENTA-FULL-COLOR
     Green/magenta anaglyph glasses, full color method.
      [image src="output-type-green-magenta.png" ]
GREEN-MAGENTA-DUBOIS
     Green/magenta anaglyph glasses, high-quality Dubois method.
      [image src="output-type-green-magenta.png" ]
AMBER-BLUE-MONOCHROME
     Amber/blue anaglyph glasses, monochrome method.
      [image src="output-type-amber-blue.png" ]
AMBER-BLUE-HALF-COLOR
     Amber/blue anaglyph glasses, half color method.
      [image src="output-type-amber-blue.png" ]
AMBER-BLUE-FULL-COLOR
     Amber/blue anaglyph glasses, full color method.
      [image src="output-type-amber-blue.png" ]
AMBER-BLUE-DUBOIS
     Amber/blue anaglyph glasses, high-quality Dubois method.
      [image src="output-type-amber-blue.png" ]
RED-GREEN-MONOCHROME
     Red/green anaglyph glasses, monochrome method.
      [image src="output-type-red-green.png" ]
RED-BLUE-MONOCHROME
     Red/blue anaglyph glasses, monochrome method.
      [image src="output-type-red-blue.png" ]
EQUALIZER
     Multi-display OpenGL via Equalizer with a 2D canvas setup.
EQUALIZER-3D
     Multi-display OpenGL via Equalizer with a 3D screen setup.

4.3 Crosstalk Ghostbusting
==========================

Many stereoscopic display devices suffer from crosstalk between the left
and right view.  This results in ghosting artifacts that can degrade the
viewing quality, depending on the video content.

   Bino can optionally reduce the ghosting artifacts.  For this, it
needs two know
  1. the amount of crosstalk of your display device and
  2. the amount of ghostbusting that is adequate for the video you want
     to watch.

   Please note that ghostbusting does not work with anaglyph glasses.

   To measure the display crosstalk, do the following:

  1. Display the ‘gamma-pattern-tb.png’ (gamma-pattern-tb.png) image and
     correct the display gamma settings according to the included
     instructions.  You need to have correct gamma settings before
     measuring crosstalk.
  2. Display the ‘crosstalk-pattern-tb.png’ (crosstalk-pattern-tb.png)
     image and determine the crosstalk levels using the included
     instructions.

   You now have three crosstalk values for the red, green, and blue
channels.  You can now tell Bino about this using the ‘--crosstalk’
option.  For example, if you have measured 8% of crosstalk for red, 12%
for green, and 10% for blue, use
     $ bino --crosstalk 0.08,0.12,0.10

   Once you know the crosstalk levels of your display device, you can
set the amount of ghostbusting that Bino should apply using the
‘--ghostbust’ option.  This will vary depending on the content you want
to watch.  Movies with very dark scenes should be viewed with at least
50% ghostbusting (‘--ghostbust 0.5’), whereas overall bright movies,
where crosstalk is less disturbing, could be viewed with a lower level
(e.g.  ‘--ghostbust 0.1’).

   To check if you crosstalk calibration is correct, display the
crosstalk patterns with full ghostbusting, like this:
     $ bino --crosstalk 0.08,0.12,0.10 --ghostbust 1.0 crosstalk-pattern-tb.png
   The remaining crosstalk should optimally be 0%.

4.4 Basic Multi Display Support
===============================

For basic multi display support, Bino requires that all displays are
connected to a single computer and are configured to display one large
desktop.  For such a setup, you can configure which screens Bino should
use in fullscreen mode.

   For example, if you have two projectors L and R that project onto a
single screen with polarization filters, and you have configured your
desktop to cover both projectors next to each other (LR), then you can
configure fullscreen mode to use both projectors and select the
‘left-right’ output technique.

   For similar setups, it is sometimes useful to mirror either the left
or the right view horizontally or vertically.  This, too, can be
configured in Bino’s fullscreen settings.

   Of course, you can also combine multiple monitors to form one large
display and use this with some other output technique, e.g.  anaglyph
glasses.

   For more advanced setups, e.g.  involving multiple computers and/or
graphics cards or non-planar projection surfaces, you can use Bino’s
advanced multi display support via Equalizer.

4.5 Advanced Multi Display Support
==================================

Bino supports distributed multi-display output via the Equalizer
framework.

   This is how it works:

4.5.1 Building Bino with Equalizer Support
------------------------------------------

First, install Equalizer 1.0 or later.  See
<http://www.equalizergraphics.com/>.  Verify that it works by running
the included ‘eqHello’ example.

   Then, build Bino with Equalizer support.  The output of configure
should contain the following line:
     Equalizer: yes

   Now you need an Equalizer configuration file for your display setup.

4.5.2 Configuring Equalizer and Starting Bino
---------------------------------------------

Bino needs a two-dimensional Equalizer canvas (= combined screen area),
subdivided into segments (= single display areas).  For example, if you
have two projectors that project onto a 2m x 1m screen side-by-side,
then your canvas is 2m x 1m large, and you have two segments: the first
segment fills the left half of the canvas, and the second segment fills
the right half.

   Next, Equalizer needs to know how to render into each segment.  For
this purpose, you define several hierarchical objects: nodes (=
processes, possibly on different systems), pipes (= graphics cards),
windows (= output windows with OpenGL contexts), and channels (= parts
of windows).  The video output happens at the channel level: each
channel is assigned to one segment of the canvas.  Most probably you
just have one fullscreen window per pipe, and a single output channel
per window.

   Note that one node is special: the application node, which is the
node that you initially start (the other nodes are started automatically
by Equalizer).  The application node is called ’appNode’ in the
Equalizer configuration, and Bino will play audio only on the
application node.  All video output is then synchronized to this audio
output.

   Once you have your configuration file (examples are given below), you
can check if it works correctly using the ‘eqHello’ example:
     $ eqHello --eq-config configuration.eqc

   Once you made sure that this works, you can start Bino using this
command:
     $ bino -o equalizer --eq-config configuration.eqc video.mp4

   Note that all your nodes need access to the video file using the same
name, so a shared filesystem is helpful if you use multiple systems.

   To play live video from a webcam or TV card, you can set up a
streaming server using ffserver (part of FFmpeg) or vlc, and then give
the appropriate URL to Bino.  You can use multicast to stream the video
to multiple systems efficiently.

   The output mode ‘-o equalizer-3d’ allows to configure non-planar
projections.  Bino projects the video onto a virtual screen in 3D space.
The screen is located in the distance of the biggest front-facing
segment, and sized to fill the wall optimally.  By configuring the
output segments accordingly, various advanced display configurations can
be used, e.g.  displays rotated around the Z axis by an arbitrary angle
or non-planar screens.

4.5.3 Example Configurations
----------------------------

Simple 2D video output
----------------------

In this example, you have a 2m x 1m screen and two projectors: one for
the left half of the screen, and one for the right half.  The two
projectors are connected to two graphics cards on the same system.

   In this situation, you have one node with two pipes, and each pipe
has a fullscreen window with a single output channel.  The first output
channel is assigned to the left segment, and the second output channel
is assigned to the right channel.  The resulting configuration looks
like this:

     server
     {
         config
         {
             appNode
             {
                 pipe { device 0 window { attributes { hint_fullscreen ON } channel { name "left" }}}
                 pipe { device 1 window { attributes { hint_fullscreen ON } channel { name "right" }}}
             }
             observer {}
             layout { view { observer 0 }}
             canvas
             {
                 layout 0
                 wall
                 {
                     bottom_left  [ 0.0  0.0 -1 ]
                     bottom_right [ 2.0  0.0 -1 ]
                     top_left     [ 0.0  1.0 -1 ]
                 }
                 segment { channel "left" viewport [ 0.0 0.0 0.5 1.0 ] }
                 segment { channel "right" viewport [ 0.5 0.0 0.5 1.0 ] }
             }
             compound
             {
                 compound { channel ( view 0 segment 0 ) swapbarrier {} }
                 compound { channel ( view 0 segment 1 ) swapbarrier {} }
             }
         }
     }

3D video output across multiple systems
---------------------------------------

In the following example, you have a 4m x 3m screen for 3D projection
via passive stereo (e.g.  polarization).  You have two systems,
"render1" and "render2", each equipped with two graphics cards.  The two
cards on "render1" generate two images for the left half of the screen:
one for the left eye view and one for the right eye view.  The two cards
on "render2" generate left and right view for the right half of the
screen.  Additionally, you have a system called "master" which has a
sound card and should display a small control window.

   This setup is very similar to the situation shown in
‘multi-display-vrlab.jpg’ (multi-display-vrlab.jpg).

   The configuration looks like this:

     server
     {
         connection { hostname "master" }
         config
         {
             appNode
             {
                 connection { hostname "master" }
                 pipe { window { viewport [ 100 100 400 300 ] channel { name "control" }}}
             }
             node
             {
                 connection { hostname "render1" }
                 pipe { device 0 window { attributes { hint_fullscreen ON } channel { name "render1left" }}}
                 pipe { device 1 window { attributes { hint_fullscreen ON } channel { name "render1right" }}}
             }
             node
             {
                 connection { hostname "render2" }
                 pipe { device 0 window { attributes { hint_fullscreen ON } channel { name "render2left" }}}
                 pipe { device 1 window { attributes { hint_fullscreen ON } channel { name "render2right" }}}
             }
             observer {}
             layout { view { observer 0 }}
             canvas
             {
                 layout 0
                 wall
                 {
                     bottom_left  [ 0.0 0.0 -1 ]
                     bottom_right [ 4.0 0.0 -1 ]
                     top_left     [ 0.0 3.0 -1 ]
                 }
                 segment { channel "render1left"  viewport [ 0.0 0.0 0.5 1.0 ] }
                 segment { channel "render1right" viewport [ 0.0 0.0 0.5 1.0 ] }
                 segment { channel "render2left"  viewport [ 0.5 0.0 0.5 1.0 ] }
                 segment { channel "render2right" viewport [ 0.5 0.0 0.5 1.0 ] }
                 segment { channel "control"      viewport [ 0.0 0.0 1.0 1.0 ] }
             }
             compound
             {
                 compound { eye [ LEFT  ] channel ( view 0 segment 0 ) swapbarrier {} }
                 compound { eye [ RIGHT ] channel ( view 0 segment 1 ) swapbarrier {} }
                 compound { eye [ LEFT  ] channel ( view 0 segment 2 ) swapbarrier {} }
                 compound { eye [ RIGHT ] channel ( view 0 segment 3 ) swapbarrier {} }
                 compound {               channel ( view 0 segment 4 ) swapbarrier {} }
             }
         }
     }

Non-planar Displays
-------------------

The ‘-o equalizer-3d’ mode allows to set up arbitrary-oriented screens
using either the wall-based or projection-based 3D frustum descriptions.

   In this example we set up two 16:10 displays side-by-side which have
been rotated around their Z axis by 1.3 degrees radians (~74 degrees).
The image ‘multi-display-rotated.jpg’ (multi-display-rotated.jpg)
illustrates this setup.  Other setups include distortion-correct
projection for curved screens, or arbitrarily-placed screens in a 3D
space.

   First, we rotate a normally-aligned screen by 1.3 degrees and output
the result:

     eq::Matrix4f matrix(eq::Matrix4f::IDENTITY);
     matrix.rotate(1.3f, eq::Vector3f::FORWARD);
     wall.bottomLeft = matrix * wall.bottomLeft;
     wall.bottomRight = matrix * wall.bottomRight;
     wall.topLeft = matrix * wall.topLeft;
     std::cout << wall << std::endl;

   yields a rotated screen centered on the origin:

     bottom_left  [   -0.69578     0.6371         -1 ]
     bottom_right [   -0.26778    -0.9046         -1 ]
     top_left     [    0.26778     0.9046         -1 ]

   This screen has to be moved along the X-axis for the left and right
screen by 0.5195m, which places the edges of the screen on the origin.
The resulting wall descriptions are used for the left and right segment,
as shown in the configuration below.

   The configuration references two GPUs full-screen output.  By
changing the node resource section, the outputs may be mapped to two
computers.  When disabling the fullscreen mode and setting ’device 0’
for the second pipe, two windows simulate this setup on a single
machine.

     global
     {
         EQ_WINDOW_IATTR_HINT_FULLSCREEN ON
     }
     
     server
     {
         config
         {
             appNode
             {
                 pipe
                 {
                     device 0
                     window
                     {
                         viewport [ .215 .5 .4 .4 ]
                         channel { name "channel1" }
                     }
                 }
                 pipe
                 {
                     device 1
                     window
                     {
                         viewport [ .285 .1 .4 .4 ]
                         attributes{ hint_drawable window }
                         channel { name "channel2" }
                     }
                 }
             }
     
             layout { view{ }}
             canvas
             {
                 layout   0
     
                 segment
                 {
                     channel  "channel1"
                     wall
                     {
                         bottom_left  [   -1.21528     0.6371         -1 ]
                         bottom_right [   -0.78728    -0.9046         -1 ]
                         top_left     [   -0.25172     0.9046         -1 ]
                     }
                 }
                 segment
                 {
                     channel  "channel2"
                     wall
                     {
                         bottom_left  [   -0.17628     0.6371         -1 ]
                         bottom_right [    0.25172    -0.9046         -1 ]
                         top_left     [    0.78728     0.9046         -1 ]
                     }
                 }
             }
     
             compound
             {
                 compound
                 {
                     channel ( segment 0 )
                     swapbarrier{}
                 }
                 compound
                 {
                     channel ( segment 1 )
                     swapbarrier{}
                 }
             }
         }
     }


File: bino.info,  Node: Interactive Control,  Next: Scripting,  Prev: Output Techniques,  Up: Top

5 Interactive Control
*********************

5.1 Keyboard Shortcuts
======================

Bino reacts on a number of keyboard shortcuts during playback.

   The following shortcuts are recognized:
‘ESC’
     Leave fullscreen mode, or quit when in window mode.
‘q’
     Quit.
‘p’
‘SPACE’
     Pause / unpause.
‘f’
     Toggle fullscreen.
‘c’
     Center window.
‘e’
‘F7’
     Swap left/right eye.
‘v’
     Cycle through available video streams.
‘a’
     Cycle through available audio streams.
‘s’
     Cycle through available subtitle streams.
‘1, 2’
     Adjust contrast.
‘3, 4’
     Adjust brightness.
‘5, 6’
     Adjust hue.
‘7, 8’
     Adjust saturation.
‘[, ]’
     Adjust parallax.
‘(, )’
     Adjust ghostbusting.
‘<, >’
     Adjust zoom for videos that are wider than the screen.
‘/, *’
     Adjust audio volume.
‘m’
     Toggle audio mute.
‘.’
     Step a single video frame forward.
‘LEFT, RIGHT’
     Seek 10 seconds backward / forward.
‘DOWN, UP’
     Seek 1 minute backward / forward.
‘PAGE DOWN, PAGE UP’
     Seek 10 minutes backward / forward.
‘Mouse click’
     Seek according to the horizontal click position.
‘"Media Keys"’
     Media keys (if available) should work as expected.

5.2 Remote Controls
===================

Bino supports remote controls via LIRC (http://www.lirc.org/).

   Use the client name ‘bino’ in your LIRC configuration.  The default
LIRC configuration file usually is ‘~/.lircrc’.  You can use the
‘--lirc-config’ option to use one or more custom LIRC configuration
files instead.

   The available commands are the same commands that are available for
scripting.  *Note Script Commands::.

   Example LIRC configuration file excerpt:
     begin
       remote = ...
       button = ...
       prog   = bino
       config = adjust-brightness +0.05
     end


File: bino.info,  Node: Scripting,  Next: Camera Devices,  Prev: Interactive Control,  Up: Top

6 Scripting
***********

Bino can read commands from one or multiple script files.  Use the
‘--read-commands’ option to specify script files.

   Available script commands are listed below.  *Note Script Commands::.

   A script file can be a standard text file, but it can also be a named
pipe, which allows other programs or scripts to submit commands to Bino
as they see fit.

     $ mkfifo ~/bino-command-fifo
     $ bino --read-commands ~/bino-command-fifo &

     $ echo 'set-contrast 0.1' > ~/bino-command-fifo
     $ ...

   Using the ‘netcat’ utility, this also works over the network.

     $ mkfifo ~/bino-command-fifo
     $ bino --read-commands ~/bino-command-fifo &

     $ nc -l 1234 > ~/bino-command-fifo &
     $ telnet localhost 1234
     set-contrast 0.1
     ...

   Here is a simple example script file:
     # Play all videos in fullscreen mode.
     toggle-fullscreen
     # Open the first video.
     open /path/to/video.webm
     # Start playing.
     play
     # Wait until the video finishes before continuing this script.
     wait stop
     # Open a second video. This one has a space in its file name.
     open /path/to/video%20file.webm
     # Start playing.
     play
     # Immediately increase brightness.
     adjust-brightness +0.1
     # Immediately seek to 60 seconds within the video.
     seek 60.0
     # Let the video play for 30.0 seconds before continuing with this script.
     wait 30.0
     # Open a third video. This one has left and right view in separate files.
     open /path/to/left.webm /path/to/right.webm
     # Start playing.
     play

   This script is executed with the following command.  The ‘--no-gui’
option is not necessary, but prevents the GUI to remember the changed
brightness setting in future sessions.
     $ bino --read-commands /path/to/script.txt --no-gui

6.1 Script Commands
===================

One script line defines exactly one script command.  Empty lines or
lines starting with the ‘#’ character are comment lines and define the
‘noop’ command, which has no effect.

‘noop’
     This command has no effect.
‘quit’
     Quit the application.
‘wait STOP|SECONDS’
     Wait until the currently playing video stops, or wait for the given
     number of seconds, before processing more commands from this file,
     script, or FIFO.
     (This command is not available for LIRC remote controls.)
‘open [OPTION...] FILE...’
     Open the given files.
     You can use percent-encoding to encode special characters.  See
     <http://en.wikipedia.org/wiki/Percent_encoding>.  Use this if the
     file names contain whitespace.
     To open devices, the following options are available, analogous to
     the command line options with the same name:
     ‘--device-type=NONE|DEFAULT|FIREWIRE|X11’
     ‘--device-frame-size=WxH’
     ‘--device-frame-rate=N/D’
     ‘--device-format=DEFAULT|MJPEG’
‘close’
     Close the currently opened input.
‘toggle-play’
     Toggle playback.
‘play’
     Start playback, or exit pause mode.
‘stop’
     Stop playback.
‘toggle-pause’
     Toggle pause mode.
‘pause’
     When playing, go into pause mode.
‘step’
     Single-step to the next video frame.
‘seek DELTA’
     Seek by the given number of seconds relative to the current
     position.  For example -60.0 seeks backwards one minute, and +600.0
     seeks forward ten minutes.
‘set-pos POS’
     Seek by setting an absolute position in the stream, with POS
     between 0 and 1.  For example, to seek to the middle of the video,
     use 0.5.
‘set-audio-device DEV’
     Set the audio device to the one with the given index.
‘set-quality Q’
     Set rendering quality, from 0 (fastest) to 4 (best, default).
‘set-stereo-mode MODE’
     Set the stereo mode.  *Note Supported Output Techniques::.
‘set-stereo-mode-swap SWAP’
     Set stereo mode left/right swap (on or off).
‘toggle-stereo-mode-swap’
     Toggle stereo mode left/right swap.
‘set-crosstalk CR CG CB’
     Set display crosstalk levels for red, green, and blue.  Each value
     must be between 0 and 1.
‘set-fullscreen-screens SCREENS’
     Set screens to use in fullscreen mode.  The value is an integer in
     which bits are set for each screen that should be used (screen 1 =
     lowest bit).  The value 0 means the default screen.
‘set-fullscreen-flip-left B’
     Set fullscreen flip left (on or off).
‘set-fullscreen-flop-leftB’
     Set fullscreen flop left (on or off).
‘set-fullscreen-flip-right B’
     Set fullscreen flip right (on or off).
‘set-fullscreen-flop-right B’
     Set fullscreen flop right (on or off).
‘set-fullscreen-inhibit-screensaver B’
     Set fullscreen inhibit screensaver (on or off).
‘set-fullscreen-3dr-sync B’
     Set fullscreen DLP® 3-D Ready Sync (on or off).
‘set-contrast VALUE’
     Set contrast to the given VALUE, from -1 to +1.
‘adjust-contrast DELTA’
     Adjust contrast by adding DELTA, e.g.  -0.05 or +0.05.
‘set-brightness VALUE’
     Set brightness to the given VALUE, from -1 to +1.
‘adjust-brightness DELTA’
     Adjust brightness by adding DELTA, e.g.  -0.05 or +0.05.
‘set-hue VALUE’
     Set hue to the given VALUE, from -1 to +1.
‘adjust-hue DELTA’
     Adjust hue by adding DELTA, e.g.  -0.05 or +0.05.
‘set-saturation VALUE’
     Set saturation to the given VALUE, from -1 to +1.
‘adjust-saturation DELTA’
     Adjust saturation by adding DELTA, e.g.  -0.05 or +0.05.
‘set-zoom VALUE’
     Set zoom to the given VALUE, from 0 to 1.
‘adjust-zoom DELTA’
     Adjust zoom by adding DELTA, e.g.  -0.05 or +0.05.
‘set-loop-mode MODE’
     Set loop mode to ‘off’ or ‘current’.
‘set-audio-delay MILLISECONDS’
     Set audio delay.
‘set-subtitle-encoding ENC’
     Set subtitle encoding.  An empty value means to use the default.
‘set-subtitle-font FONT’
     Set subtitle font.  An empty value means to use the default.
‘set-subtitle-size SIZE’
     Set the subtitle font size.  The value is an integer, e.g.  12.
     Use -1 to keep the default size.
‘set-subtitle-color COLOR’
     Set the subtitle color as an integer that represents an RGB color.
     Use a value larger than UINT32_MAX to keep the default color.
‘set-subtitle-shadow MODE’
     Set subtitle shadow to force-on (1), force-off (0), or default
     (-1).
‘set-video-stream STREAM’
     Set video stream.  Stream numbers start with 0.
‘cycle-video-stream’
     Cycle through available video streams.
‘set-audio-stream STREAM’
     Set audio stream.  Stream numbers start with 0.
‘cycle-audio-stream’
     Cycle through available audio streams.
‘set-subtitle-stream STREAM’
     Set subtitle stream.  Stream numbers start with 0.  Using -1
     disables subtitles.
‘cycle-subtitle-stream’
     Cycle through available subtitle streams.
‘set-stereo-layout LAYOUT’
     Set stereo layout.  *Note Supported Input Layouts::.  Note that
     here only the left first, right second modes are supported.  To get
     the right first, left second modes, use ‘set-stereo-layout-swap’.
‘set-stereo-layout-swap B’
     Set stereo layout swap (on or off).
‘set-crop-aspect-ratio AR’
     Set crop aspect ratio, either as a floating point number (e.g.
     1.78), or as a ratio (e.g.  16:9).
‘set-parallax VALUE’
     Set parallax, from -1 to +1.
‘adjust-parallax DELTA’
     Adjust parallax by adding DELTA, e.g.  -0.05 or + 0.05.
‘set-ghostbust VALUE’
     Set ghostbust, from -1 to +1.
‘adjust-ghostbust DELTA’
     Adjust ghostbust by adding DELTA, e.g.  -0.05 or + 0.05.
‘set-subtitle-parallax VALUE’
     Set subtitle parallax, from -1 to +1.
‘adjust-subtitle-parallax DELTA’
     Adjust subtitle parallax by adding DELTA, e.g.  -0.05 or + 0.05.
‘toggle-fullscreen’
     Toggle fullscreen.
‘center’
     Center window.
‘set-audio-volume VALUE’
     Set audio volume, from 0 to 1.
‘adjust-audio-volume DELTA’
     Adjust audio volume by adding DELTA, e.g.  -0.05 or +0.05.
‘toggle-audio-mute’
     Toggle audio mute.
‘set-vertical-pixel-shift-left =L’
     Set left vertical shift in input pixels.
‘set-vertical-pixel-shift-right R’
     Set right vertical shift in input pixels.


File: bino.info,  Node: Camera Devices,  Next: Audio/Video Synchronization,  Prev: Scripting,  Up: Top

7 Camera Devices
****************

Bino supports the following types of camera devices:
   • DEFAULT: the system-specific default device type.
     This is video4linux2 on GNU/Linux, bktr on BSD and Mac OS, and VfW
     on Windows.  This should work for all webcams and similar camera
     devices.
   • FIREWIRE: Firewire devices.
   • X11: X11-grabber pseudo devices.
     This device type allows to capture part of an X11 screen as a
     video.  It requires the user to select a specific frame size and
     frame rate.  The device name is of the form
     ‘[HOSTNAME]:DISPLAY.SCREEN[+X,Y]’.  For example,
     ‘smith:0.0+160,120’ would capture from X11 display ‘:0.0’ on host
     ‘smith’, starting at position ‘160,120’.

   Note: for FIREWIRE and X11 devices to work, your FFmpeg libraries
must have LIBDC1394 and X11GRAB support enabled.


File: bino.info,  Node: Audio/Video Synchronization,  Next: Performance Tweaking,  Prev: Camera Devices,  Up: Top

8 Audio/Video Synchronization
*****************************

Bino uses OpenGL to display video, and OpenGL unfortunately does not
provide a way to determine exactly when a frame will be visible on
screen.  On most systems, a frame is displayed almost immediately, but
some systems introduce a delay, and this can cause notable audio/video
synchronization errors.  This effect may be aggravated by compositing
window managers.  See bug 35103 (http://savannah.nongnu.org/bugs/?35103)
for more information.

   You can check the audio/video synchronization on your system using
the file ‘audio-video-sync.mp4’ (audio-video-sync.mp4) (created on
12/18/2011 by S. Christian Collins (http://www.schristiancollins.com)).
It contains a few bright flashes accompanied by "tick" sounds.  The
flashes and the sounds should be exactly in sync.

   If they are not, you can adjust an audio delay that compensates for
the video delay.  Increase audio delay (e.g.  in steps of 50
milliseconds) and replay the test video until audio and video are
synchronized.


File: bino.info,  Node: Performance Tweaking,  Prev: Audio/Video Synchronization,  Up: Top

9 Performance Tweaking
**********************

Bino should be able to play most video files on a computer with
reasonable CPU and graphics power.

   If Bino cannot play a video fast enough, it drops frames.  Audio
continues to play, but video begins to stutter or even to stop
completely.

   This can have to two causes: either your CPU cannot decode the video
fast enough, or your graphics card cannot render the video fast enough.

   In the first case, there is currently not much you can do.

   In the second case, try the following to improve performance:
  1. Reduce the quality setting as far as necessary.
  2. Use a lower-quality anaglyph mode instead of the high-quality
     Dubois mode.
  3. Avoid color adjustments: set the contrast, brightness, hue, and
     saturation adjustments to 0.
  4. Avoid ghostbusting: set the ghostbusting parameter to 0.
  5. Disable subtitles.



Tag Table:
Node: Top766
Node: Introduction1586
Node: Invocation2615
Node: Input Layouts7269
Ref: Supported Input Layouts8179
Ref: File Name Conventions10247
Node: Output Techniques11159
Ref: Supported Output Techniques13894
Ref: Crosstalk Ghostbusting17827
Ref: Basic Multi Display Support19831
Ref: Advanced Multi Display Support20973
Node: Interactive Control32291
Node: Scripting34309
Ref: Script Commands36293
Node: Camera Devices42746
Node: Audio/Video Synchronization43725
Node: Performance Tweaking44892

End Tag Table


Local Variables:
coding: utf-8
End:
